'use strict';

exports.__esModule = true;

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var Slider = (function (_Component) {
  _inherits(Slider, _Component);

  _createClass(Slider, null, [{
    key: 'propTypes',
    value: {
      min: _react.PropTypes.number,
      max: _react.PropTypes.number,
      step: _react.PropTypes.number,
      minDistance: _react.PropTypes.number,
      defaultValue: _react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.arrayOf(_react.PropTypes.number)]),
      value: _react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.arrayOf(_react.PropTypes.number)]),
      orientation: _react.PropTypes.oneOf(['horizontal', 'vertical']),
      disabled: _react.PropTypes.bool,
      snapDragDisabled: _react.PropTypes.bool,
      onBeforeChange: _react.PropTypes.func,
      onChange: _react.PropTypes.func,
      onAfterChange: _react.PropTypes.func,
      onSliderClick: _react.PropTypes.func,
      theme: _react.PropTypes.object,
      children: _react.PropTypes.array
    },
    enumerable: true
  }, {
    key: 'defaultProps',
    value: {
      min: 0,
      max: 100,
      step: 1,
      minDistance: 0,
      defaultValue: 0,
      orientation: 'horizontal',
      disabled: false,
      snapDragDisabled: false
    },
    enumerable: true
  }]);

  function Slider(props) {
    var _this = this;

    _classCallCheck(this, Slider);

    _Component.call(this, props);

    this.pauseEvent = function (e) {
      if (e.stopPropagation) e.stopPropagation();
      if (e.preventDefault) e.preventDefault();
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    };

    this.stopPropagation = function (e) {
      if (e.stopPropagation) e.stopPropagation();
      e.cancelBubble = true;
    };

    this.orChildrenCount = function (value, defaultValue) {
      var count = _react.Children.count(_this.props.children);
      switch (count) {
        case 0:
          return value.length > 0 ? value : defaultValue;
        case value.length:
          return value;
        case defaultValue.length:
          return defaultValue;
        default:
          return _this.linspace(_this.props.min, _this.props.max, count);
      }
    };

    this.updateSlider = function () {
      var slider = _reactDom.findDOMNode(_this.refs.slider);
      var handle = _reactDom.findDOMNode(_this.refs.handle);
      var rect = slider.getBoundingClientRect();

      var size = _this.sizeKey();

      var sliderMax = rect[_this.posMaxKey()];
      var sliderMin = rect[_this.posMinKey()];

      _this.setState({
        upperBound: slider[size] - handle[size],
        sliderLength: Math.abs(sliderMax - sliderMin),
        handleSize: handle[size],
        sliderStart: sliderMin
      });
    };

    this.componentDidMount = function () {
      if (typeof window !== 'undefined') {
        var ResizeSensor = require('css-element-queries/src/ResizeSensor');
        var slider = _reactDom.findDOMNode(_this.refs.slider);
        _this.sliderResizeSensor = new ResizeSensor(slider, _this.updateSlider);
      }
      _this.updateSlider();
    };

    this.componentWillUnmount = function () {
      if (_this.sliderResizeSensor) {
        _this.sliderResizeSensor.detach();
      }
    };

    this.getValue = function () {
      return _this.undoEnsureArray(_this.state.value);
    };

    this.calcOffset = function (value) {
      var dividend = _this.props.max - _this.props.min === 0 ? 1 : _this.props.max - _this.props.min;
      var ratio = (value - _this.props.min) / dividend;
      return ratio * _this.state.upperBound;
    };

    this.calcValue = function (offset) {
      var ratio = offset / _this.state.upperBound;
      return ratio * (_this.props.max - _this.props.min) + _this.props.min;
    };

    this.buildHandleStyle = function (offset) {
      var _ref;

      return _ref = {
        position: 'absolute',
        willChange: _this.state.index >= 0 ? _this.posMinKey() : '',
        zIndex: 1,
        background: _this.props.theme.base06,
        cursor: 'hand',
        width: '25px',
        height: '25px',
        borderRadius: '50%',
        marginTop: '20px'
      }, _ref[_this.posMinKey()] = offset, _ref;
    };

    this.buildBarStyle = function () {
      return {
        position: 'absolute',
        willChange: _this.state.index >= 0 ? _this.posMinKey() + ',' + _this.posMaxKey() : '',
        background: _this.props.theme.base06,
        top: '60%',
        height: '10%',
        width: '98%',
        left: 7,
        cursor: 'hand'
      };
    };

    this.getClosestIndex = function (pixelOffset) {
      var minDist = Number.MAX_VALUE;
      var closestIndex = -1;

      var value = _this.state.value;
      var l = value.length;

      for (var i = 0; i < l; i++) {
        var offset = _this.calcOffset(value[i]);
        var dist = Math.abs(pixelOffset - offset);
        if (dist < minDist) {
          minDist = dist;
          closestIndex = i;
        }
      }

      return closestIndex;
    };

    this.calcOffsetFromPosition = function (position) {
      var pixelOffset = position - _this.state.sliderStart;
      pixelOffset -= _this.state.handleSize / 2;
      return pixelOffset;
    };

    this.forceValueFromPosition = function (position, callback) {
      var pixelOffset = _this.calcOffsetFromPosition(position);
      var closestIndex = _this.getClosestIndex(pixelOffset);
      var nextValue = _this.trimAlignValue(_this.calcValue(pixelOffset));

      var value = _this.state.value.slice(); // Clone this.state.value since we'll modify it temporarily
      value[closestIndex] = nextValue;

      // Prevents the slider from shrinking below `props.minDistance`
      for (var i = 0; i < value.length - 1; i += 1) {
        if (value[i + 1] - value[i] < _this.props.minDistance) return;
      }

      _this.setState({ value: value }, callback.bind(_this, closestIndex));
    };

    this.getMousePosition = function (e) {
      return [e['page' + _this.axisKey()], e['page' + _this.orthogonalAxisKey()]];
    };

    this.getTouchPosition = function (e) {
      var touch = e.touches[0];
      return [touch['page' + _this.axisKey()], touch['page' + _this.orthogonalAxisKey()]];
    };

    this.getMouseEventMap = function () {
      return {
        'mousemove': _this.onMouseMove,
        'mouseup': _this.onMouseUp
      };
    };

    this.getTouchEventMap = function () {
      return {
        'touchmove': _this.onTouchMove,
        'touchend': _this.onTouchEnd
      };
    };

    this.createOnMouseDown = function (i) {
      return (function createdOnMouseDown(e) {
        if (this.props.disabled) return;
        var position = this.getMousePosition(e);
        this.start(i, position[0]);
        this.addHandlers(this.getMouseEventMap());
        this.pauseEvent(e);
      }).bind(_this);
    };

    this.createOnTouchStart = function (i) {
      return (function createdOnTouchStart(e) {
        if (this.props.disabled || e.touches.length > 1) return;
        var position = this.getTouchPosition(e);
        this.startPosition = position;
        this.isScrolling = undefined; // don't know yet if the user is trying to scroll
        this.start(i, position[0]);
        this.addHandlers(this.getTouchEventMap());
        this.stopPropagation(e);
      }).bind(_this);
    };

    this.addHandlers = function (eventMap) {
      for (var key in eventMap) {
        if (({}).hasOwnProperty.call(eventMap, key)) {
          document.addEventListener(key, eventMap[key], false);
        }
      }
    };

    this.removeHandlers = function (eventMap) {
      for (var key in eventMap) {
        if (({}).hasOwnProperty.call(eventMap, key)) {
          document.removeEventListener(key, eventMap[key], false);
        }
      }
    };

    this.start = function (i, position) {
      // if activeElement is body window will lost focus in IE9
      if (document.activeElement && document.activeElement !== document.body) {
        document.activeElement.blur();
      }

      _this.hasMoved = false;

      _this.fireChangeEvent('onBeforeChange');

      var zIndices = _this.state.zIndices;
      zIndices.splice(zIndices.indexOf(i), 1); // remove wherever the element is
      zIndices.push(i); // add to end

      _this.setState({
        startValue: _this.state.value[i],
        startPosition: position,
        index: i,
        zIndices: zIndices
      });
    };

    this.onMouseUp = function () {
      _this.onEnd(_this.getMouseEventMap());
    };

    this.onTouchEnd = function () {
      _this.onEnd(_this.getTouchEventMap());
    };

    this.onEnd = function (eventMap) {
      _this.removeHandlers(eventMap);
      _this.setState({ index: -1 }, _this.fireChangeEvent.bind(_this, 'onAfterChange'));
    };

    this.onMouseMove = function (e) {
      var position = _this.getMousePosition(e);
      _this.move(position[0]);
    };

    this.onTouchMove = function (e) {
      if (e.touches.length > 1) return;

      var position = _this.getTouchPosition(e);

      if (typeof _this.isScrolling === 'undefined') {
        var diffMainDir = position[0] - _this.startPosition[0];
        var diffScrollDir = position[1] - _this.startPosition[1];
        _this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);
      }

      if (_this.isScrolling) {
        _this.setState({ index: -1 });
        return;
      }

      _this.pauseEvent(e);

      _this.move(position[0]);
    };

    this.move = function (position) {
      _this.hasMoved = true;

      var _props = _this.props;
      var max = _props.max;
      var min = _props.min;
      var _state = _this.state;
      var index = _state.index;
      var value = _state.value;
      var startValue = _state.startValue;
      var sliderLength = _state.sliderLength;
      var handleSize = _state.handleSize;

      var oldValue = value[index];

      var diffPosition = position - _this.state.startPosition;

      var diffValue = diffPosition / (sliderLength - handleSize) * (max - min);
      var newValue = _this.trimAlignValue(startValue + diffValue);

      value[index] = newValue;

      // Normally you would use `shouldComponentUpdate`, but since the slider is a low-level component,
      // the extra complexity might be worth the extra performance.
      if (newValue !== oldValue) {
        _this.setState({ value: value }, _this.fireChangeEvent.bind(_this, 'onChange'));
      }
    };

    this.pushSucceeding = function (value, minDistance, index) {
      var i = undefined;
      var padding = undefined;
      for (i = index, padding = value[i] + minDistance; value[i + 1] !== null && padding > value[i + 1]; i++, padding = value[i] + minDistance) {
        value[i + 1] = _this.alignValue(padding);
      }
    };

    this.trimSucceeding = function (length, nextValue, minDistance, max) {
      for (var i = 0; i < length; i++) {
        var padding = max - i * minDistance;
        if (nextValue[length - 1 - i] > padding) {
          nextValue[length - 1 - i] = padding;
        }
      }
    };

    this.pushPreceding = function (value, minDistance, index) {
      var i = undefined;
      var padding = undefined;
      for (i = index, padding = value[i] - minDistance; value[i - 1] !== null && padding < value[i - 1]; i--, padding = value[i] - minDistance) {
        value[i - 1] = _this.alignValue(padding);
      }
    };

    this.trimPreceding = function (length, nextValue, minDistance, min) {
      for (var i = 0; i < length; i++) {
        var padding = min + i * minDistance;
        if (nextValue[i] < padding) {
          nextValue[i] = padding;
        }
      }
    };

    this.axisKey = function () {
      var orientation = _this.props.orientation;
      if (orientation === 'horizontal') return 'X';
      if (orientation === 'vertical') return 'Y';
    };

    this.orthogonalAxisKey = function () {
      return _this.props.orientation === 'horizontal' ? 'Y' : 'X';
    };

    this.posMinKey = function () {
      return _this.props.orientation === 'horizontal' ? 'left' : 'top';
    };

    this.posMaxKey = function () {
      return _this.props.orientation === 'horizontal' ? 'right' : 'bottom';
    };

    this.sizeKey = function () {
      return _this.props.orientation === 'horizontal' ? 'clientWidth' : 'clientHeight';
    };

    this.trimAlignValue = function (val, props) {
      return _this.alignValue(_this.trimValue(val, props), props);
    };

    this.trimValue = function (val, props) {
      var newProps = props || _this.props;

      var newVal = val;
      if (val <= newProps.min) {
        newVal = newProps.min;
      }
      if (val >= newProps.max) {
        newVal = newProps.max;
      }

      return newVal;
    };

    this.alignValue = function (val, props) {
      var newProps = props || _this.props;

      var valModStep = (val - newProps.min) % newProps.step;
      var alignValue = val - valModStep;

      if (Math.abs(valModStep) * 2 >= newProps.step) {
        alignValue += valModStep > 0 ? newProps.step : -newProps.step;
      }

      return parseFloat(alignValue.toFixed(5));
    };

    this.renderHandle = function (child) {
      var offset = _this.calcOffset(_this.props.value);

      return _react2['default'].createElement(
        'div',
        {
          ref: 'handle', key: 'handle',
          style: _this.buildHandleStyle(offset),
          onMouseDown: _this.createOnMouseDown(0),
          onTouchStart: _this.createOnTouchStart(0)
        },
        child
      );
    };

    this.renderBar = function () {
      return _react2['default'].createElement('div', { key: 'bar', ref: 'bar', style: _this.buildBarStyle() });
    };

    this.onSliderMouseDown = function (e) {
      if (_this.props.disabled) return;
      _this.hasMoved = false;
      if (!_this.props.snapDragDisabled) {
        (function () {
          var position = _this.getMousePosition(e);
          _this.forceValueFromPosition(position[0], (function forceValueFromPosition(i) {
            this.fireChangeEvent('onChange');
            this.start(i, position[0]);
            this.addHandlers(this.getMouseEventMap());
          }).bind(_this));
        })();
      }

      _this.pauseEvent(e);
    };

    this.onSliderClick = function (e) {
      if (_this.props.disabled) return;

      if (_this.props.onSliderClick && !_this.hasMoved) {
        var position = _this.getMousePosition(e);
        var valueAtPos = _this.trimAlignValue(_this.calcValue(_this.calcOffsetFromPosition(position[0])));
        _this.props.onSliderClick(valueAtPos);
      }
    };

    this.fireChangeEvent = function (event) {
      if (_this.props[event]) {
        _this.props[event](_this.undoEnsureArray(_this.state.value));
      }
    };

    this.renderValue = function () {
      var _props2 = _this.props;
      var value = _props2.value;
      var min = _props2.min;
      var max = _props2.max;

      var style = {
        position: 'absolute',
        left: _this.calcOffset(value) + 6,
        color: _this.props.theme.base06
      };

      if (value !== min && value !== max) {
        return _react2['default'].createElement(
          'small',
          { style: style },
          value
        );
      }
      return _react2['default'].createElement('small', null);
    };

    var value = this.orChildrenCount(this.ensureArray(this.props.value), this.ensureArray(this.props.defaultValue));
    // reused throughout the component to store results of iterations over `value`
    this.tempArray = value.slice();

    var zIndices = [];
    for (var i = 0; i < value.length; i++) {
      value[i] = this.trimAlignValue(value[i], this.props);
      zIndices.push(i);
    }

    this.state = {
      index: -1,
      upperBound: 0,
      sliderLength: 0,
      value: value,
      zIndices: zIndices
    };
  }

  Slider.prototype.linspace = function linspace(min, max, count) {
    var range = (max - min) / (count - 1);
    var res = [];
    for (var i = 0; i < count; i++) {
      res.push(min + range * i);
    }
    return res;
  };

  Slider.prototype.ensureArray = function ensureArray(x) {
    if (x === null) {
      return [];
    }
    if (Array.isArray(x)) {
      return x;
    }
    return [x];
  };

  Slider.prototype.undoEnsureArray = function undoEnsureArray(x) {
    return x !== null && x.length === 1 ? x[0] : x;
  };

  Slider.prototype.render = function render() {
    var bars = this.renderBar();
    var handle = this.renderHandle(null);
    var currentValue = this.renderValue();

    return _react2['default'].createElement(
      'div',
      null,
      _react2['default'].createElement(
        'div',
        { ref: 'slider',
          style: {
            position: 'relative',
            width: '100%',
            height: '50px',
            marginBottom: '12px'
          },
          onMouseDown: this.onSliderMouseDown,
          onClick: this.onSliderClick
        },
        bars,
        handle
      ),
      _react2['default'].createElement(
        'div',
        { style: { position: 'relative', bottom: 10 } },
        _react2['default'].createElement(
          'small',
          { style: { left: 7, position: 'absolute', color: this.props.theme.base06 } },
          this.props.min
        ),
        currentValue,
        _react2['default'].createElement(
          'small',
          { style: { right: 5, position: 'absolute', color: this.props.theme.base06 } },
          this.props.max
        )
      )
    );
  };

  return Slider;
})(_react.Component);

exports['default'] = Slider;
module.exports = exports['default'];

// calculates the offset of a handle in pixels based on its value.

// calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.

// Snaps the nearest handle to the value corresponding to `position` and calls `callback` with that handle's index.

// create the `mousedown` handler for the i-th handle

// create the `touchstart` handler for the i-th handle